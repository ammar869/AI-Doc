# Export Functionality Guide

## Overview
This guide covers implementing document export functionality in multiple formats (PDF, DOCX, HTML, TXT) with proper formatting, styling, and metadata.

## Step 1: Export Service Layer

### Install Dependencies

```bash
# Install export dependencies
npm install jspdf html2canvas
npm install docx pizzip
npm install mammoth
```

### Create Export Service

Create `src/lib/document/exporter.ts`:

```typescript
import jsPDF from 'jspdf'
import { Document as DocxDocument, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx'
import mammoth from 'mammoth'

export interface ExportOptions {
  format: 'pdf' | 'docx' | 'html' | 'txt'
  includeMetadata?: boolean
  includeTableOfContents?: boolean
  pageOrientation?: 'portrait' | 'landscape'
  margins?: {
    top: number
    right: number
    bottom: number
    left: number
  }
  customStyles?: Record<string, any>
}

export interface ExportMetadata {
  title: string
  author?: string
  subject?: string
  keywords?: string[]
  createdAt: Date
  modifiedAt: Date
  wordCount: number
  pageCount?: number
}

export class DocumentExporter {
  private static defaultMargins = {
    top: 72,     // 1 inch
    right: 72,   // 1 inch
    bottom: 72,  // 1 inch
    left: 72     // 1 inch
  }

  static async exportDocument(
    content: string,
    title: string,
    options: ExportOptions,
    metadata?: Partial<ExportMetadata>
  ): Promise<Blob> {
    switch (options.format) {
      case 'pdf':
        return await this.exportToPDF(content, title, options, metadata)
      case 'docx':
        return await this.exportToDOCX(content, title, options, metadata)
      case 'html':
        return await this.exportToHTML(content, title, options, metadata)
      case 'txt':
        return await this.exportToTXT(content, title, options, metadata)
      default:
        throw new Error(`Unsupported export format: ${options.format}`)
    }
  }

  private static async exportToPDF(
    content: string,
    title: string,
    options: ExportOptions,
    metadata?: Partial<ExportMetadata>
  ): Promise<Blob> {
    const pdf = new jsPDF({
      orientation: options.pageOrientation || 'portrait',
      unit: 'pt',
      format: 'a4'
    })

    const margins = options.margins || this.defaultMargins
    const pageWidth = pdf.internal.pageSize.getWidth()
    const pageHeight = pdf.internal.pageSize.getHeight()
    const contentWidth = pageWidth - margins.left - margins.right
    const contentHeight = pageHeight - margins.top - margins.bottom

    // Add metadata
    if (options.includeMetadata && metadata) {
      pdf.setProperties({
        title: metadata.title || title,
        subject: metadata.subject,
        author: metadata.author,
        keywords: metadata.keywords?.join(', '),
        creator: 'AI Document Creator',
      })
    }

    let yPosition = margins.top

    // Add title
    if (title) {
      pdf.setFontSize(18)
      pdf.setFont('helvetica', 'bold')
      const titleLines = pdf.splitTextToSize(title, contentWidth)
      pdf.text(titleLines, margins.left, yPosition)
      yPosition += (titleLines.length * 20) + 20
    }

    // Add metadata if requested
    if (options.includeMetadata && metadata) {
      pdf.setFontSize(10)
      pdf.setFont('helvetica', 'normal')
      
      const metaLines = [
        `Created: ${metadata.createdAt?.toLocaleDateString() || new Date().toLocaleDateString()}`,
        `Modified: ${metadata.modifiedAt?.toLocaleDateString() || new Date().toLocaleDateString()}`,
        `Word Count: ${metadata.wordCount || 0}`,
        `Generated by: AI Document Creator`
      ]

      metaLines.forEach(line => {
        pdf.text(line, margins.left, yPosition)
        yPosition += 12
      })
      
      yPosition += 20
    }

    // Process content
    const processedContent = this.processHTMLContent(content)
    
    // Add content
    pdf.setFontSize(12)
    pdf.setFont('helvetica', 'normal')
    
    const lines = pdf.splitTextToSize(processedContent, contentWidth)
    
    for (const line of lines) {
      if (yPosition > pageHeight - margins.bottom) {
        pdf.addPage()
        yPosition = margins.top
      }
      pdf.text(line, margins.left, yPosition)
      yPosition += 16
    }

    return new Blob([pdf.output('blob')], { type: 'application/pdf' })
  }

  private static async exportToDOCX(
    content: string,
    title: string,
    options: ExportOptions,
    metadata?: Partial<ExportMetadata>
  ): Promise<Blob> {
    const children: any[] = []

    // Add title
    if (title) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: title,
              bold: true,
              size: 32,
            }),
          ],
          heading: HeadingLevel.TITLE,
          alignment: AlignmentType.CENTER,
        })
      )
    }

    // Add metadata if requested
    if (options.includeMetadata && metadata) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: '',
              break: 1,
            }),
          ],
        })
      )
      
      const metaLines = [
        `Created: ${metadata.createdAt?.toLocaleDateString() || new Date().toLocaleDateString()}`,
        `Modified: ${metadata.modifiedAt?.toLocaleDateString() || new Date().toLocaleDateString()}`,
        `Word Count: ${metadata.wordCount || 0}`,
        `Generated by: AI Document Creator`
      ]

      metaLines.forEach(line => {
        children.push(
          new Paragraph({
            children: [
              new TextRun({
                text: line,
                size: 20,
              }),
            ],
          })
        )
      })
      
      children.push(
        new Paragraph({
          children: [
            new TextRun({
              text: '',
              break: 1,
            }),
          ],
        })
      )
    }

    // Process and add content
    const paragraphs = this.parseContentToParagraphs(content)
    children.push(...paragraphs)

    // Create document
    const doc = new DocxDocument({
      sections: [{
        properties: {
          page: {
            margin: {
              top: options.margins?.top || this.defaultMargins.top / 72, // Convert to inches
              right: options.margins?.right || this.defaultMargins.right / 72,
              bottom: options.margins?.bottom || this.defaultMargins.bottom / 72,
              left: options.margins?.left || this.defaultMargins.left / 72,
            },
          },
        },
        children,
      }],
    })

    // Add document properties
    if (options.includeMetadata && metadata) {
      doc.coreProperties = {
        title: metadata.title || title,
        subject: metadata.subject,
        creator: metadata.author || 'AI Document Creator',
        keywords: metadata.keywords,
      }
    }

    return await Packer.toBlob(doc)
  }

  private static async exportToHTML(
    content: string,
    title: string,
    options: ExportOptions,
    metadata?: Partial<ExportMetadata>
  ): Promise<Blob> {
    const processedContent = this.processHTMLContent(content)
    
    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(title)}</title>
    ${this.generateStyles(options.customStyles)}
    ${this.generateMetadata(metaData)}
</head>
<body>
    <div class="document-container">
        <header class="document-header">
            <h1 class="document-title">${this.escapeHtml(title)}</h1>
            ${options.includeMetadata ? this.generateMetadataBlock(metadata) : ''}
        </header>
        
        <main class="document-content">
            ${processedContent}
        </main>
        
        <footer class="document-footer">
            <p class="generated-by">Generated by AI Document Creator</p>
            <p class="generated-date">${new Date().toLocaleDateString()}</p>
        </footer>
    </div>
</body>
</html>`

    return new Blob([html], { type: 'text/html' })
  }

  private static async exportToTXT(
    content: string,
    title: string,
    options: ExportOptions,
    metadata?: Partial<ExportMetadata>
  ): Promise<Blob> {
    let txt = ''

    // Add title
    if (title) {
      txt += `${title}\n`
      txt += '='.repeat(title.length) + '\n\n'
    }

    // Add metadata if requested
    if (options.includeMetadata && metadata) {
      txt += 'Document Information:\n'
      txt += '-'.repeat(20) + '\n'
      txt += `Created: ${metadata.createdAt?.toLocaleDateString() || new Date().toLocaleDateString()}\n`
      txt += `Modified: ${metadata.modifiedAt?.toLocaleDateString() || new Date().toLocaleDateString()}\n`
      txt += `Word Count: ${metadata.wordCount || 0}\n`
      txt += `Generated by: AI Document Creator\n\n`
      txt += '-'.repeat(50) + '\n\n'
    }

    // Add content (strip HTML tags)
    const plainText = content.replace(/<[^>]*>/g, '')
    txt += plainText

    return new Blob([txt], { type: 'text/plain' })
  }

  private static processHTMLContent(content: string): string {
    // Basic HTML processing
    return content
      .replace(/<h1([^>]*)>/gi, '<h1 class="heading-1"$1>')
      .replace(/<h2([^>]*)>/gi, '<h2 class="heading-2"$1>')
      .replace(/<h3([^>]*)>/gi, '<h3 class="heading-3"$1>')
      .replace(/<p([^>]*)>/gi, '<p class="paragraph"$1>')
      .replace(/<strong([^>]*)>/gi, '<strong class="bold"$1>')
      .replace(/<em([^>]*)>/gi, '<em class="italic"$1>')
      .replace(/<ul([^>]*)>/gi, '<ul class="list"$1>')
      .replace(/<ol([^>]*)>/gi, '<ol class="list-numbered"$1>')
      .replace(/<li([^>]*)>/gi, '<li class="list-item"$1>')
  }

  private static parseContentToParagraphs(content: string): Paragraph[] {
    const sections = content.split(/\n\s*\n/).filter(section => section.trim())
    
    return sections.map(section => {
      const trimmed = section.trim()
      if (!trimmed) {
        return new Paragraph({})
      }

      // Detect headings
      if (trimmed.startsWith('# ')) {
        return new Paragraph({
          children: [
            new TextRun({
              text: trimmed.substring(2),
              bold: true,
              size: 28,
            }),
          ],
          heading: HeadingLevel.HEADING_1,
        })
      }

      if (trimmed.startsWith('## ')) {
        return new Paragraph({
          children: [
            new TextRun({
              text: trimmed.substring(3),
              bold: true,
              size: 26,
            }),
          ],
          heading: HeadingLevel.HEADING_2,
        })
      }

      if (trimmed.startsWith('### ')) {
        return new Paragraph({
          children: [
            new TextRun({
              text: trimmed.substring(4),
              bold: true,
              size: 24,
            }),
          ],
          heading: HeadingLevel.HEADING_3,
        })
      }

      // Regular paragraph
      return new Paragraph({
        children: [
          new TextRun({
            text: trimmed,
            size: 24,
          }),
        ],
      })
    })
  }

  private static generateStyles(customStyles?: Record<string, any>): string {
    const defaultStyles = `
    <style>
        body {
            font-family: 'Times New Roman', serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        .document-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .document-header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
        }
        .document-title {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .document-content {
            flex: 1;
            font-size: 16px;
        }
        .document-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        .heading-1 { 
            font-size: 2em; 
            color: #2c3e50; 
            margin-top: 30px;
            margin-bottom: 15px;
        }
        .heading-2 { 
            font-size: 1.5em; 
            color: #34495e; 
            margin-top: 25px;
            margin-bottom: 12px;
        }
        .heading-3 { 
            font-size: 1.25em; 
            color: #34495e; 
            margin-top: 20px;
            margin-bottom: 10px;
        }
        .paragraph { 
            margin-bottom: 16px; 
            text-align: justify;
        }
        .bold { font-weight: bold; }
        .italic { font-style: italic; }
        .list { 
            margin: 16px 0; 
            padding-left: 30px;
        }
        .list-item { 
            margin-bottom: 8px; 
        }
        .metadata-block {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            font-size: 14px;
        }
        .metadata-item {
            margin: 5px 0;
        }
        .metadata-label {
            font-weight: bold;
            color: #495057;
        }
        @media print {
            body { font-size: 12px; }
            .document-title { font-size: 2em; }
            .document-footer { display: none; }
        }
    </style>`

    if (!customStyles) {
      return defaultStyles
    }

    // Merge custom styles
    return defaultStyles.replace('</style>', `
        ${Object.entries(customStyles).map(([selector, styles]) => 
          `${selector} { ${Object.entries(styles).map(([prop, value]) => `${prop}: ${value}`).join('; ')} }`
        ).join('\n')}
    </style>`)
  }

  private static generateMetadata(metaData?: Partial<ExportMetadata>): string {
    if (!metaData) return ''

    return `
    <meta name="author" content="${this.escapeHtml(metaData.author || 'AI Document Creator')}">
    <meta name="description" content="Document: ${this.escapeHtml(metaData.title || '')}">
    <meta name="generator" content="AI Document Creator">
    <meta name="keywords" content="${this.escapeHtml(metaData.keywords?.join(', ') || '')}">
    <meta name="created" content="${metaData.createdAt?.toISOString() || new Date().toISOString()}">
    <meta name="modified" content="${metaData.modifiedAt?.toISOString() || new Date().toISOString()}">`
  }

  private static generateMetadataBlock(metadata?: Partial<ExportMetadata>): string {
    if (!metadata) return ''

    return `
    <div class="metadata-block">
        <div class="metadata-item">
            <span class="metadata-label">Created:</span> 
            ${metadata.createdAt?.toLocaleDateString() || new Date().toLocaleDateString()}
        </div>
        <div class="metadata-item">
            <span class="metadata-label">Modified:</span> 
            ${metadata.modifiedAt?.toLocaleDateString() || new Date().toLocaleDateString()}
        </div>
        <div class="metadata-item">
            <span class="metadata-label">Word Count:</span> 
            ${metadata.wordCount || 0}
        </div>
        <div class="metadata-item">
            <span class="metadata-label">Generated by:</span> 
            AI Document Creator
        </div>
    </div>`
  }

  private static escapeHtml(text: string): string {
    const div = document.createElement('div')
    div.textContent = text
    return div.innerHTML
  }

  // Utility method to get export filename
  static getExportFilename(title: string, format: string): string {
    const cleanTitle = title
      .replace(/[^a-zA-Z0-9\s-]/g, '')
      .trim()
      .replace(/\s+/g, '-')
      .toLowerCase()
    
    return `${cleanTitle || 'document'}.${format}`
  }

  // Utility method to get MIME type
  static getMimeType(format: string): string {
    const mimeTypes: Record<string, string> = {
      pdf: 'application/pdf',
      docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      html: 'text/html',
      txt: 'text/plain'
    }
    
    return mimeTypes[format] || 'application/octet-stream'
  }
}
```

## Step 2: Export API Routes

### Create Export API Route

Create `src/app/api/documents/[id]/export/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { DocumentExporter, ExportOptions } from '@/lib/document/exporter'
import { z } from 'zod'

const exportSchema = z.object({
  format: z.enum(['pdf', 'docx', 'html', 'txt']),
  includeMetadata: z.boolean().optional(),
  includeTableOfContents: z.boolean().optional(),
  pageOrientation: z.enum(['portrait', 'landscape']).optional(),
  customStyles: z.record(z.string()).optional(),
})

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const supabase = createServerSupabaseClient()
  
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()
  const validation = exportSchema.safeParse(body)
  
  if (!validation.success) {
    return NextResponse.json({ 
      error: 'Invalid export request',
      details: validation.error.errors 
    }, { status: 400 })
  }

  const { format, includeMetadata = true, includeTableOfContents = false, 
           pageOrientation = 'portrait', customStyles } = validation.data

  // Get document
  const { data: document, error } = await supabase
    .from('documents')
    .select('*')
    .eq('id', params.id)
    .eq('user_id', user.id)
    .single()

  if (error) {
    if (error.code === 'PGRST116') {
      return NextResponse.json({ error: 'Document not found' }, { status: 404 })
    }
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  try {
    const options: ExportOptions = {
      format,
      includeMetadata,
      includeTableOfContents,
      pageOrientation,
      customStyles,
    }

    const metadata = {
      title: document.title,
      author: user.user_metadata?.full_name || user.email,
      createdAt: new Date(document.created_at),
      modifiedAt: new Date(document.updated_at),
      wordCount: document.word_count,
      subject: document.type,
      keywords: [document.type, 'document', 'ai-generated'],
    }

    const blob = await DocumentExporter.exportDocument(
      document.content || '',
      document.title,
      options,
      metadata
    )

    const filename = DocumentExporter.getExportFilename(document.title, format)
    const mimeType = DocumentExporter.getMimeType(format)

    return new NextResponse(blob, {
      headers: {
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Type': mimeType,
        'Content-Length': blob.size.toString(),
      },
    })
  } catch (error) {
    console.error('Export error:', error)
    return NextResponse.json(
      { error: 'Failed to export document' }, 
      { status: 500 }
    )
  }
}
```

### Create Batch Export Route

Create `src/app/api/documents/export/batch/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase/server'
import { DocumentExporter, ExportOptions } from '@/lib/document/exporter'
import JSZip from 'jszip'
import { z } from 'zod'

const batchExportSchema = z.object({
  documentIds: z.array(z.string().uuid()),
  format: z.enum(['pdf', 'docx', 'html', 'txt']),
  includeMetadata: z.boolean().optional(),
})

export async function POST(request: NextRequest) {
  const supabase = createServerSupabaseClient()
  
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const body = await request.json()
  const validation = batchExportSchema.safeParse(body)
  
  if (!validation.success) {
    return NextResponse.json({ 
      error: 'Invalid batch export request',
      details: validation.error.errors 
    }, { status: 400 })
  }

  const { documentIds, format, includeMetadata = true } = validation.data

  try {
    // Get all documents
    const { data: documents, error } = await supabase
      .from('documents')
      .select('*')
      .in('id', documentIds)
      .eq('user_id', user.id)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    if (!documents || documents.length === 0) {
      return NextResponse.json({ error: 'No documents found' }, { status: 404 })
    }

    // Create ZIP file
    const zip = new JSZip()

    // Export each document
    for (const document of documents) {
      const options: ExportOptions = {
        format,
        includeMetadata,
      }

      const metadata = {
        title: document.title,
        author: user.user_metadata?.full_name || user.email,
        createdAt: new Date(document.created_at),
        modifiedAt: new Date(document.updated_at),
        wordCount: document.word_count,
        subject: document.type,
        keywords: [document.type, 'document', 'ai-generated'],
      }

      const blob = await DocumentExporter.exportDocument(
        document.content || '',
        document.title,
        options,
        metadata
      )

      const filename = DocumentExporter.getExportFilename(document.title, format)
      zip.file(filename, blob)
    }

    // Create manifest file
    const manifest = {
      exportedAt: new Date().toISOString(),
      format,
      includeMetadata,
      documents: documents.map(doc => ({
        id: doc.id,
        title: doc.title,
        type: doc.type,
        wordCount: doc.word_count,
        filename: DocumentExporter.getExportFilename(doc.title, format),
      })),
      totalDocuments: documents.length,
    }

    zip.file('manifest.json', JSON.stringify(manifest, null, 2))

    // Generate ZIP
    const zipBlob = await zip.generateAsync({ type: 'blob' })
    const filename = `documents-export-${new Date().toISOString().split('T')[0]}.zip`

    return new NextResponse(zipBlob, {
      headers: {
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Type': 'application/zip',
        'Content-Length': zipBlob.size.toString(),
      },
    })
  } catch (error) {
    console.error('Batch export error:', error)
    return NextResponse.json(
      { error: 'Failed to export documents' }, 
      { status: 500 }
    )
  }
}
```

## Step 3: Export Components

### Create Export Modal Component

Create `src/components/document/export-modal.tsx`:

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Switch } from '@/components/ui/switch'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Download, FileText, File, Code, Type, Loader2 } from 'lucide-react'

interface ExportModalProps {
  isOpen: boolean
  onClose: () => void
  documentId: string
  documentTitle: string
  documentType?: string
  wordCount?: number
  onExport?: (format: string, options: any) => void
}

export function ExportModal({
  isOpen,
  onClose,
  documentId,
  documentTitle,
  documentType,
  wordCount,
  onExport
}: ExportModalProps) {
  const [selectedFormat, setSelectedFormat] = useState('pdf')
  const [includeMetadata, setIncludeMetadata] = useState(true)
  const [includeTOC, setIncludeTOC] = useState(false)
  const [pageOrientation, setPageOrientation] = useState('portrait')
  const [isExporting, setIsExporting] = useState(false)

  const formats = [
    {
      id: 'pdf',
      name: 'PDF',
      description: 'Best for sharing and printing',
      icon: FileText,
      recommended: true,
    },
    {
      id: 'docx',
      name: 'Word Document',
      description: 'Editable in Microsoft Word',
      icon: File,
    },
    {
      id: 'html',
      name: 'HTML',
      description: 'Web-compatible format',
      icon: Code,
    },
    {
      id: 'txt',
      name: 'Plain Text',
      description: 'Simple text format',
      icon: Type,
    },
  ]

  const handleExport = async () => {
    setIsExporting(true)
    
    try {
      const options = {
        format: selectedFormat,
        includeMetadata,
        includeTableOfContents: includeTOC,
        pageOrientation,
      }

      // Call API to export
      const response = await fetch(`/api/documents/${documentId}/export`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(options),
      })

      if (!response.ok) {
        throw new Error('Export failed')
      }

      const blob = await response.blob()
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `${documentTitle.replace(/[^a-zA-Z0-9]/g, '_')}.${selectedFormat}`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      onExport?.(selectedFormat, options)
      onClose()
    } catch (error) {
      console.error('Export failed:', error)
      alert('Export failed. Please try again.')
    } finally {
      setIsExporting(false)
    }
  }

  const getFileSizeEstimate = () => {
    const baseSize = (wordCount || 1000) * 0.001 // Rough estimate in KB
    const multipliers = {
      pdf: 1.5,
      docx: 1.2,
      html: 0.8,
      txt: 0.5,
    }
    return Math.round(baseSize * (multipliers[selectedFormat as keyof typeof multipliers] || 1))
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Export Document</DialogTitle>
          <DialogDescription>
            Choose your preferred format and options for exporting "{documentTitle}"
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-6">
          {/* Document Info */}
          <Card>
            <CardContent className="pt-4">
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <Label className="text-muted-foreground">Type</Label>
                  <p className="font-medium capitalize">{documentType || 'Document'}</p>
                </div>
                <div>
                  <Label className="text-muted-foreground">Word Count</Label>
                  <p className="font-medium">{wordCount?.toLocaleString() || 0}</p>
                </div>
                <div>
                  <Label className="text-muted-foreground">Estimated Size</Label>
                  <p className="font-medium">~{getFileSizeEstimate()} KB</p>
                </div>
                <div>
                  <Label className="text-muted-foreground">Export Date</Label>
                  <p className="font-medium">{new Date().toLocaleDateString()}</p>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Format Selection */}
          <div className="space-y-3">
            <Label>Export Format</Label>
            <div className="grid grid-cols-1 gap-2">
              {formats.map((format) => {
                const Icon = format.icon
                return (
                  <div
                    key={format.id}
                    className={`relative flex cursor-pointer rounded-lg border p-4 hover:bg-accent hover:text-accent-foreground ${
                      selectedFormat === format.id ? 'border-primary bg-primary/5' : ''
                    }`}
                    onClick={() => setSelectedFormat(format.id)}
                  >
                    {format.recommended && (
                      <div className="absolute -top-2 -right-2">
                        <div className="bg-primary text-primary-foreground text-xs px-2 py-1 rounded-full">
                          Recommended
                        </div>
                      </div>
                    )}
                    <div className="flex items-center space-x-3">
                      <Icon className="h-5 w-5" />
                      <div className="flex-1">
                        <div className="font-medium">{format.name}</div>
                        <div className="text-sm text-muted-foreground">{format.description}</div>
                      </div>
                    </div>
                    {selectedFormat === format.id && (
                      <div className="absolute right-2 top-1/2 transform -translate-y-1/2">
                        <div className="h-2 w-2 rounded-full bg-primary" />
                      </div>
                    )}
                  </div>
                )
              })}
            </div>
          </div>

          {/* Options */}
          <div className="space-y-4">
            <Label>Options</Label>
            
            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label className="text-sm">Include Metadata</Label>
                <p className="text-xs text-muted-foreground">
                  Add document information and generation details
                </p>
              </div>
              <Switch
                checked={includeMetadata}
                onCheckedChange={setIncludeMetadata}
              />
            </div>

            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label className="text-sm">Table of Contents</Label>
                <p className="text-xs text-muted-foreground">
                  Include automatically generated TOC (PDF/DOCX only)
                </p>
              </div>
              <Switch
                checked={includeTOC}
                onCheckedChange={setIncludeTOC}
                disabled={!['pdf', 'docx'].includes(selectedFormat)}
              />
            </div>

            {selectedFormat === 'pdf' && (
              <div className="space-y-2">
                <Label className="text-sm">Page Orientation</Label>
                <Select value={pageOrientation} onValueChange={setPageOrientation}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="portrait">Portrait</SelectItem>
                    <SelectItem value="landscape">Landscape</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            )}
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isExporting}>
            Cancel
          </Button>
          <Button onClick={handleExport} disabled={isExporting}>
            {isExporting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Exporting...
              </>
            ) : (
              <>
                <Download className="mr-2 h-4 w-4" />
                Export {formats.find(f => f.id === selectedFormat)?.name}
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

### Create Batch Export Component

Create `src/components/document/batch-export-modal.tsx`:

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Label } from '@/components/ui/label'
import { Checkbox } from '@/components/ui/checkbox'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Card, CardContent } from '@/components/ui/card'
import { Loader2, Download, Package } from 'lucide-react'
import { Document } from '@/types/document'

interface BatchExportModalProps {
  isOpen: boolean
  onClose: () => void
  documents: Document[]
  onExport?: (documentIds: string[], format: string) => void
}

export function BatchExportModal({
  isOpen,
  onClose,
  documents,
  onExport
}: BatchExportModalProps) {
  const [selectedDocuments, setSelectedDocuments] = useState<string[]>([])
  const [selectedFormat, setSelectedFormat] = useState('pdf')
  const [includeMetadata, setIncludeMetadata] = useState(true)
  const [isExporting, setIsExporting] = useState(false)

  const formats = [
    { id: 'pdf', name: 'PDF' },
    { id: 'docx', name: 'Word Document' },
    { id: 'html', name: 'HTML' },
    { id: 'txt', name: 'Plain Text' },
  ]

  const handleDocumentToggle = (documentId: string) => {
    setSelectedDocuments(prev => 
      prev.includes(documentId) 
        ? prev.filter(id => id !== documentId)
        : [...prev, documentId]
    )
  }

  const handleSelectAll = () => {
    if (selectedDocuments.length === documents.length) {
      setSelectedDocuments([])
    } else {
      setSelectedDocuments(documents.map(doc => doc.id))
    }
  }

  const handleExport = async () => {
    if (selectedDocuments.length === 0) return

    setIsExporting(true)
    
    try {
      const response = await fetch('/api/documents/export/batch', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          documentIds: selectedDocuments,
          format: selectedFormat,
          includeMetadata,
        }),
      })

      if (!response.ok) {
        throw new Error('Batch export failed')
      }

      const blob = await response.blob()
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `documents-export-${new Date().toISOString().split('T')[0]}.zip`
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      onExport?.(selectedDocuments, selectedFormat)
      onClose()
    } catch (error) {
      console.error('Batch export failed:', error)
      alert('Batch export failed. Please try again.')
    } finally {
      setIsExporting(false)
    }
  }

  const totalWordCount = selectedDocuments
    .map(id => documents.find(doc => doc.id === id)?.word_count || 0)
    .reduce((sum, count) => sum + count, 0)

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[600px] max-h-[80vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle>Batch Export Documents</DialogTitle>
          <DialogDescription>
            Select documents to export as a ZIP file
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-hidden space-y-4">
          {/* Selection Controls */}
          <Card>
            <CardContent className="pt-4">
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center space-x-2">
                  <Checkbox
                    checked={selectedDocuments.length === documents.length}
                    onCheckedChange={handleSelectAll}
                  />
                  <Label className="text-sm font-medium">
                    {selectedDocuments.length === documents.length ? 'Deselect All' : 'Select All'}
                  </Label>
                </div>
                <div className="text-sm text-muted-foreground">
                  {selectedDocuments.length} of {documents.length} selected
                </div>
              </div>

              {/* Format and Options */}
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label className="text-sm">Export Format</Label>
                  <Select value={selectedFormat} onValueChange={setSelectedFormat}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      {formats.map(format => (
                        <SelectItem key={format.id} value={format.id}>
                          {format.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                
                <div className="flex items-center space-x-2 mt-6">
                  <Checkbox
                    checked={includeMetadata}
                    onCheckedChange={setIncludeMetadata}
                  />
                  <Label className="text-sm">Include metadata</Label>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Document List */}
          <div className="flex-1 overflow-y-auto border rounded-lg">
            <div className="p-2 space-y-1">
              {documents.map((document) => (
                <div
                  key={document.id}
                  className="flex items-center space-x-3 p-3 rounded hover:bg-accent"
                >
                  <Checkbox
                    checked={selectedDocuments.includes(document.id)}
                    onCheckedChange={() => handleDocumentToggle(document.id)}
                  />
                  <div className="flex-1 min-w-0">
                    <div className="font-medium truncate">{document.title}</div>
                    <div className="text-sm text-muted-foreground flex items-center gap-2">
                      <span className="capitalize">{document.type}</span>
                      <span>•</span>
                      <span>{document.word_count} words</span>
                      <span>•</span>
                      <span className="capitalize">{document.status}</span>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Summary */}
          {selectedDocuments.length > 0 && (
            <Card>
              <CardContent className="pt-4">
                <div className="grid grid-cols-3 gap-4 text-center">
                  <div>
                    <div className="text-lg font-semibold">{selectedDocuments.length}</div>
                    <div className="text-sm text-muted-foreground">Documents</div>
                  </div>
                  <div>
                    <div className="text-lg font-semibold">{totalWordCount.toLocaleString()}</div>
                    <div className="text-sm text-muted-foreground">Total Words</div>
                  </div>
                  <div>
                    <div className="text-lg font-semibold">
                      ~{Math.round(totalWordCount * 0.001)} KB
                    </div>
                    <div className="text-sm text-muted-foreground">Est. Size</div>
                  </div>
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isExporting}>
            Cancel
          </Button>
          <Button 
            onClick={handleExport} 
            disabled={selectedDocuments.length === 0 || isExporting}
          >
            {isExporting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Exporting...
              </>
            ) : (
              <>
                <Package className="mr-2 h-4 w-4" />
                Export {selectedDocuments.length} Documents
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}
```

## Step 4: Export Hook

Create `src/hooks/use-export.ts`:

```typescript
'use client'

import { useState } from 'react'

export interface ExportOptions {
  format: 'pdf' | 'docx' | 'html' | 'txt'
  includeMetadata?: boolean
  includeTableOfContents?: boolean
  pageOrientation?: 'portrait' | 'landscape'
  customStyles?: Record<string, any>
}

export interface BatchExportOptions extends ExportOptions {
  documentIds: string[]
}

export function useExport() {
  const [isExporting, setIsExporting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const exportDocument = async (
    documentId: string, 
    options: ExportOptions
  ): Promise<boolean> => {
    setIsExporting(true)
    setError(null)

    try {
      const response = await fetch(`/api/documents/${documentId}/export`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(options),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Export failed')
      }

      const blob = await response.blob()
      
      // Get filename from response headers or generate one
      const contentDisposition = response.headers.get('Content-Disposition')
      let filename = `document.${options.format}`
      
      if (contentDisposition) {
        const matches = /filename="([^"]+)"/.exec(contentDisposition)
        if (matches) {
          filename = matches[1]
        }
      }

      // Trigger download
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      return true
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Export failed'
      setError(errorMessage)
      throw new Error(errorMessage)
    } finally {
      setIsExporting(false)
    }
  }

  const batchExport = async (
    options: BatchExportOptions
  ): Promise<boolean> => {
    setIsExporting(true)
    setError(null)

    try {
      const response = await fetch('/api/documents/export/batch', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          documentIds: options.documentIds,
          format: options.format,
          includeMetadata: options.includeMetadata,
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Batch export failed')
      }

      const blob = await response.blob()
      
      // Generate filename
      const filename = `documents-export-${new Date().toISOString().split('T')[0]}.zip`

      // Trigger download
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

      return true
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Batch export failed'
      setError(errorMessage)
      throw new Error(errorMessage)
    } finally {
      setIsExporting(false)
    }
  }

  const getExportHistory = async (): Promise<any[]> => {
    // This would typically fetch from an API
    // For now, return empty array
    return []
  }

  return {
    exportDocument,
    batchExport,
    getExportHistory,
    isExporting,
    error,
    clearError: () => setError(null),
  }
}
```

## Step 5: Testing Export Functionality

### Test Single Document Export

```typescript
import { DocumentExporter } from '@/lib/document/exporter'

export async function testSingleExport() {
  try {
    const content = '<h1>Test Document</h1><p>This is a test document.</p>'
    const title = 'Test Document'
    
    const options = {
      format: 'pdf' as const,
      includeMetadata: true,
      pageOrientation: 'portrait' as const,
    }
    
    const metadata = {
      title,
      author: 'Test User',
      createdAt: new Date(),
      modifiedAt: new Date(),
      wordCount: 5,
    }
    
    const blob = await DocumentExporter.exportDocument(content, title, options, metadata)
    
    // Test download
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'test-document.pdf'
    a.click()
    URL.revokeObjectURL(url)
    
    console.log('Export successful')
  } catch (error) {
    console.error('Export failed:', error)
  }
}
```

### Test Batch Export

```typescript
export async function testBatchExport() {
  try {
    const documents = [
      { id: '1', title: 'Document 1', content: 'Content 1', word_count: 100 },
      { id: '2', title: 'Document 2', content: 'Content 2', word_count: 200 },
    ]
    
    // This would be handled by the batch export API
    console.log('Batch export test completed')
  } catch (error) {
    console.error('Batch export failed:', error)
  }
}
```

## Performance Considerations

1. **Memory Usage**: Large documents may require chunked processing
2. **File Size**: Monitor generated file sizes and implement compression
3. **Processing Time**: Consider async processing for large documents
4. **Format Optimization**: Optimize each format for size and quality

## Security Considerations

1. **Content Sanitization**: Sanitize HTML content before export
2. **File Access**: Ensure users can only export their own documents
3. **Rate Limiting**: Implement rate limiting for export endpoints
4. **Metadata Protection**: Be careful with sensitive metadata in exports

## Accessibility

1. **Alt Text**: Ensure proper alt text for images in exports
2. **Structure**: Maintain semantic HTML structure in exports
3. **Reading Order**: Preserve logical reading order in exports
4. **Color Contrast**: Ensure sufficient contrast in styled exports

## Next Steps

Now that export functionality is implemented, proceed to:
1. [Security Implementation Guide](./08-security-guide.md)
2. [Deployment Guide](./09-deployment-guide.md)

This completes the export functionality implementation. You now have comprehensive document export capabilities in multiple formats with proper styling, metadata, and batch processing features.